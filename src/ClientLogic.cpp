/**
 * Encrypted File Transfer Client
 * @file ClientLogic.cpp
 * @brief The core logic of Client.
 * ClientLogic received commands from ClientMenu and invokes internal logic such as FileHandler, SocketHandler.
 * @author Arthur Rennert
 */

#include "pch.h"
#include "ClientLogic.h"
#include "Stringer.h"
#include "RSAWrapper.h"
#include "AESWrapper.h"
#include "FileHandler.h"
#include "SocketHandler.h"


ClientLogic::ClientLogic() : _fileHandler(nullptr), _socketHandler(nullptr), _rsaDecryptor(nullptr)
{
	_fileHandler = new FileHandler();
	_socketHandler = new SocketHandler();
}

ClientLogic::~ClientLogic()
{
	delete _fileHandler;
	delete _socketHandler;
	delete _rsaDecryptor;
}

/**
 * Parse SERVER_INFO file for file name.
 */
bool ClientLogic::parseFileName(std::string& fileName)
{
	if (!_fileHandler->open(SERVER_INFO))
	{
		clearLastError();
		_lastError << "Couldn't open " << SERVER_INFO;
		return false;
	}

	std::string info;
	// Skip first 2 lines
	for (int i = 0; i < 3; i++)
	{
		if (!_fileHandler->readLine(info))
		{
			clearLastError();
			_lastError << "Couldn't read file name from: " << SERVER_INFO;
			return false;
		}
	}
	
	_fileHandler->close();
	Stringer::trim(info);
	fileName = info;

	return true;
}

/**
 * Parse SERVER_INFO file for server address & port.
 */
bool ClientLogic::parseServeInfo()
{
	if (!_fileHandler->open(SERVER_INFO))
	{
		clearLastError();
		_lastError << "Couldn't open " << SERVER_INFO;
		return false;
	}
	std::string info;
	if (!_fileHandler->readLine(info))
	{
		clearLastError();
		_lastError << "Couldn't read " << SERVER_INFO;
		return false;
	}
	_fileHandler->close();
	Stringer::trim(info);
	const auto pos = info.find(':');
	if (pos == std::string::npos)
	{
		clearLastError();
		_lastError << SERVER_INFO << " has invalid format! missing separator ':'";
		return false;
	}
	const auto address = info.substr(0, pos);
	const auto port = info.substr(pos + 1);
	if (!_socketHandler->setSocketInfo(address, port))
	{
		clearLastError();
		_lastError << SERVER_INFO << " has invalid IP address or port!";
		return false;
	}
	return true;
}

/**
 * Parse SERVER_INFO file for an unregistered client.
 */
bool ClientLogic::parseUnregisteredClientInfo(std::string& username)
{
	if (!_fileHandler->open(SERVER_INFO))
	{
		clearLastError();
		_lastError << "Couldn't open " << SERVER_INFO;
		return false;
	}

	std::string line;
	// Skip first line
	if (!_fileHandler->readLine(line))
	{
		clearLastError();
		_lastError << "Couldn't read from " << SERVER_INFO;
		return false;
	}

	//Read username
	if (!_fileHandler->readLine(line))
	{
		clearLastError();
		_lastError << "Couldn't read username from " << SERVER_INFO;
		return false;
	}

	if (line.length() >= CLIENT_NAME_SIZE)
	{
		clearLastError();
		_lastError << "Invalid username read from " << SERVER_INFO;
		return false;
	}

	username = line;
	Stringer::trim(username);
	return true;
}

/**
 * Returns whether RSA key pair was generated by the user already.
 */
bool ClientLogic::isRSAGenerated()
{
	return _self.publicKeySet;
}

/**
 * Returns whether crc was successfully validated with the server.
 */
bool ClientLogic::isCRCValid()
{
	return _self.validCRC;
}

/**
 * Returns whether Symmetric key was set (received from the server).
 */
bool ClientLogic::isSymmetricKeySet()
{
	return _self.symmetricKeySet;
}

/**
 * Parse CLIENT_INFO file for a registered client.
 */
bool ClientLogic::parseRegisteredClientInfo()
{
	std::string line;
	if (!_fileHandler->open(CLIENT_INFO))
	{
		clearLastError();
		_lastError << "Couldn't open " << CLIENT_INFO;
		return false;
	}

	// Read & Parse username
	if (!_fileHandler->readLine(line))
	{
		clearLastError();
		_lastError << "Couldn't read username from " << CLIENT_INFO;
		return false;
	}
	Stringer::trim(line);
	if (line.length() >= CLIENT_NAME_SIZE)
	{
		clearLastError();
		_lastError << "Invalid username read from " << CLIENT_INFO;
		return false;
	}
	_self.username = line;

	// Read & Parse Client's UUID.
	if (!_fileHandler->readLine(line))
	{
		clearLastError();
		_lastError << "Couldn't read client's UUID from " << CLIENT_INFO;
		return false;
	}
	
	line = Stringer::unhex(line);
	const char* unhexed = line.c_str();
	if (strlen(unhexed) != sizeof(_self.id.uuid))
	{
		memset(_self.id.uuid, 0, sizeof(_self.id.uuid));
		clearLastError();
		_lastError << "Couldn't parse client's UUID from " << CLIENT_INFO;
		return false;
	}
	memcpy(_self.id.uuid, unhexed, sizeof(_self.id.uuid));

	// Read & Parse Client's private key.
	std::string decodedKey;
	while (_fileHandler->readLine(line))
	{
		decodedKey.append(Stringer::decodeBase64(line));
	}
	if (decodedKey.empty()) //RSA pair not yet generated.
	{
		_self.publicKeySet = false;
		return true;
	}
	try
	{
		delete _rsaDecryptor;
		_rsaDecryptor = new RSAPrivateWrapper(decodedKey);

	}
	catch (...)
	{
		clearLastError();
		_lastError << "Couldn't parse private key from " << CLIENT_INFO;
		return false;
	}

	_self.publicKeySet = true;
	_fileHandler->close();
	return true;
}


/**
 * Reset _lastError StringStream: Empty string, clear errors flag and reset formatting.
 */
void ClientLogic::clearLastError()
{
	const std::stringstream clean;
	_lastError.str("");
	_lastError.clear();
	_lastError.copyfmt(clean);
}

/**
 * Store client info to CLIENT_INFO file.
 */
bool ClientLogic::storeClientInfo()
{
	if (!_fileHandler->open(CLIENT_INFO, true))
	{
		clearLastError();
		_lastError << "Couldn't open " << CLIENT_INFO;
		return false;
	}

	// Write username
	if (!_fileHandler->writeLine(_self.username))
	{
		clearLastError();
		_lastError << "Couldn't write username to " << CLIENT_INFO;
		return false;
	}

	// Write UUID.
	const auto hexifiedUUID = Stringer::hex(_self.id.uuid, sizeof(_self.id.uuid));
	if (!_fileHandler->writeLine(hexifiedUUID))
	{
		clearLastError();
		_lastError << "Couldn't write UUID to " << CLIENT_INFO;
		return false;
	}

	_fileHandler->close();
	return true;
}

/**
 * Store client RSA key to CLIENT_INFO file.
 */
bool ClientLogic::storeClientRSA()
{
	if (!_fileHandler->openToAppend(CLIENT_INFO))
	{
		clearLastError();
		_lastError << "Couldn't open " << CLIENT_INFO;
		return false;
	}

	// Write Base64 encoded private key
	const auto encodedKey = Stringer::encodeBase64(_rsaDecryptor->getPrivateKey());
	if (!_fileHandler->write(reinterpret_cast<const uint8_t*>(encodedKey.c_str()), encodedKey.size()))
	{
		clearLastError();
		_lastError << "Couldn't write client's private key to " << CLIENT_INFO;
		return false;
	}

	_fileHandler->close();
	return true;
}

/**
 * Validate ResponseHeader upon an expected ResponseCode.
 */
bool ClientLogic::validateHeader(const ResponseHeader& header, const ResponseCode expectedCode)
{
	if (header.code == RESPONSE_ERROR)
	{
		clearLastError();
		_lastError << "Generic error response code (" << RESPONSE_ERROR << ") received.";
		return false;
	}

	if (header.code != expectedCode)
	{
		clearLastError();
		_lastError << "Unexpected response code " << header.code << " received. Expected code was " << expectedCode;
		return false;
	}

	csize_t expectedSize = DEFAULT_VALUE;
	switch (header.code)
	{
		case RESPONSE_REGISTRATION_SUCCESS:
		{
			expectedSize = sizeof(ResponseRegistrationSucceed);
			break;
		}
		case RESPONSE_REGISTRATION_FAILED:
		{
			expectedSize = sizeof(ResponseRegistrationFailed);
			break;
		}
		case RESPONSE_ENCRYPTED_AES_KEY:
		{
			expectedSize = sizeof(ResponseEncryptedKey);
			break;
		}
		case RESPONSE_SUCCESS_FILE_WITH_CRC:
		{
			expectedSize = sizeof(ResponseFileAcception);
			break;
		}
		case RESPONSE_MSG_RECEIVED_THANKS:
		{
			expectedSize = sizeof(ResponseMSGReceived);
			break;
		}
		default:
		{
			return true;  // variable payload size. 
		}
	}
	
	expectedSize -= sizeof(ResponseHeader);

	if (header.payloadSize != expectedSize)
	{
		clearLastError();
		_lastError << "Unexpected payload size " << header.payloadSize << ". Expected size was " << expectedSize;
		return false;
	}
	return true;
}

/**
 * Generate RSA key pair.
 */
bool ClientLogic::generateRSAPair()
{
	delete _rsaDecryptor;
	_rsaDecryptor = new RSAPrivateWrapper();
	const auto publicKey = _rsaDecryptor->getPublicKey();
	if (publicKey.size() != PUBLIC_KEY_SIZE)
	{
		clearLastError();
		_lastError << "Invalid public key length!";
		return false;
	}
	memcpy(_self.publicKey.publicKey, publicKey.c_str(), sizeof(_self.publicKey));
	if (!storeClientRSA())
	{
		clearLastError();
		_lastError << "Failed writing client RSA key to " << CLIENT_INFO << ".";
		return false;
	}
	return true;
}

/**
 * Change RSA key pair.
 */
bool ClientLogic::changeRSAPair()
{
	if (!storeClientInfo())
	{
		clearLastError();
		_lastError << "Failed writing client info to " << CLIENT_INFO << ".";
		return false;
	}

	generateRSAPair();
	return true;
}

/**
 * Register client via the server.
 */
bool ClientLogic::registerClient(const std::string& username)
{
	RequestRegistration  request;
	ResponseRegistrationSucceed response;

	if (username.length() >= CLIENT_NAME_SIZE)  // >= because of null termination.
	{
		clearLastError();
		_lastError << "Invalid username length!";
		return false;
	}
	for (auto ch : username)
	{
		if (!std::isalnum(ch) && ch != ' ')  // check that username is alphanumeric. [a-zA-Z0-9].
		{
			clearLastError();
			_lastError << "Invalid username! Username may only contain letters and numbers and a space!";
			return false;
		}
	}

	// fill request data
	request.header.payloadSize = sizeof(request.clientName);
	strcpy_s(reinterpret_cast<char*>(request.clientName.name), CLIENT_NAME_SIZE, username.c_str());
	if (!_socketHandler->sendReceive(reinterpret_cast<const uint8_t* const>(&request), sizeof(request),
		reinterpret_cast<uint8_t* const>(&response), sizeof(response)))
	{
		clearLastError();
		_lastError << "Failed communicating with server on " << _socketHandler;
		return false;
	}

	if (response.header.code == RESPONSE_REGISTRATION_FAILED)
	{
		ResponseRegistrationFailed responseFail;
		responseFail.header.code = response.header.code;
		responseFail.header.version = response.header.version;
		responseFail.header.payloadSize = response.header.payloadSize;

		// Validate ResponseRegistrationFailed
		if (!validateHeader(responseFail.header, RESPONSE_REGISTRATION_FAILED))
			return false;  // error message updated within.

		clearLastError();
		_lastError << "Registration failed.";
		return false;
	}
	else
	{
		// Validate ResponseRegistrationSucceed
		if (!validateHeader(response.header, RESPONSE_REGISTRATION_SUCCESS))
			return false;  // error message updated within.
	}

	// Store received client's ID
	_self.id = response.payload;
	_self.username = username;
	if (!storeClientInfo())
	{
		clearLastError();
		_lastError << "Failed writing client info to " << CLIENT_INFO << ". Please register again with different username.";
		return false;
	}
	return true;
}

/**
 * Send RSA public key to server.
 */
bool ClientLogic::sendPublicKey()
{
	RequestSendPublicKey request;
	ResponseEncryptedKey response;

	const auto publicKey = _rsaDecryptor->getPublicKey();
	request.header.payloadSize = sizeof(request.payload);
	strcpy_s(reinterpret_cast<char*>(request.payload.clientName.name), CLIENT_NAME_SIZE, _self.username.c_str());
	memcpy(request.payload.clientPublicKey.publicKey, publicKey.c_str(), sizeof(request.payload.clientPublicKey.publicKey));
	_self.publicKey = request.payload.clientPublicKey;
	if (!_socketHandler->sendReceive(reinterpret_cast<const uint8_t* const>(&request), sizeof(request),
		reinterpret_cast<uint8_t* const>(&response), sizeof(response)))
	{
		clearLastError();
		_lastError << "Failed communicating with server on " << _socketHandler;
		return false;
	}
	
	// Validate ResponseEncryptedKey
	if (!validateHeader(response.header, RESPONSE_ENCRYPTED_AES_KEY))
		return false;  // error message updated within.

	std::string key;
	try
	{
		key = _rsaDecryptor->decrypt(response.payload.encryptedAESKey.encryptedAESKey, ENCRYPTED_AES_KEY_SIZE);
	}
	catch (std::exception& e)
	{
		std::cout << "Standard exception: " << e.what() << std::endl;
	}
	memcpy(_self.symmetricKey.symmetricKey, key.c_str(), AES_KEY_SIZE);
	_self.symmetricKeySet = true;
	return true;
}

/**
 * Calculate crc of str.
 */
uint32_t ClientLogic::getCRC(const std::string& str)
{
	boost::crc_32_type result;
	result.process_bytes(str.c_str(), str.size());
	return result.checksum();
}

/**
 * Send server that crc validated.
 */
bool ClientLogic::informServerCRCValidated(uint8_t* fileName)
{
	RequestValidCRC request(_self.id);
	ResponseMSGReceived response;

	memcpy(request.file.fileName, fileName, FILE_NAME_SIZE);

	if (!_socketHandler->sendReceive(reinterpret_cast<const uint8_t* const>(&request), sizeof(request),
		reinterpret_cast<uint8_t* const>(&response), sizeof(response)))
	{
		clearLastError();
		_lastError << "Failed communicating with server on " << _socketHandler;
		return false;
	}

	// Validate ResponseMSGReceived
	if (!validateHeader(response.header, RESPONSE_MSG_RECEIVED_THANKS))
		return false;  // error message updated within.

	_self.validCRC = true;
	return true;
}

/**
 * Send server that crc not validated.
 */
void ClientLogic::informServerCRCFailed(const size_t size)
{
	// size = remaining send to server failed crc retry times
	if (size == 0)
	{
		RequestInvalidCRCAbort request(_self.id);
		ResponseMSGReceived response;

		if (!_socketHandler->sendReceive(reinterpret_cast<const uint8_t* const>(&request), sizeof(request),
			reinterpret_cast<uint8_t* const>(&response), sizeof(response)))
		{
			clearLastError();
			_lastError << "Failed communicating with server on " << _socketHandler;
			return;
		}

		// Validate ResponseMSGReceived
		if (!validateHeader(response.header, RESPONSE_MSG_RECEIVED_THANKS))
			return;  // error message updated within.

		std::cout << "Server has received CRC fail message." << std::endl;
	}
	else
	{
		RequestInvalidCRC request(_self.id);

		if (!_socketHandler->sendOnly(reinterpret_cast<const uint8_t* const>(&request), sizeof(request)))
		{
			clearLastError();
			_lastError << "Failed communicating with server on " << _socketHandler;
			return;
		}
	}
}

/**
 * Send a file to the server.
 */
bool ClientLogic::sendFile(bool& sent)
{
	RequestSendFile request(_self.id);
	ResponseFileAcception response;

	std::string filePath;

	if (!parseFileName(filePath)){
		return false;
	}

	strcpy_s(reinterpret_cast<char*>(request.PayloadHeader.file.fileName), FILE_NAME_SIZE, filePath.c_str());

	uint8_t* file = nullptr;
	size_t bytes;
	if (!_fileHandler->readAtOnce(filePath, file, bytes))
	{
		clearLastError();
		_lastError << "File not found!";
		return false;
	}

	std::string temp = (char*)file;
	std::string textBeforeEnc = temp.substr(0, bytes);

	const auto fileCRC = getCRC(textBeforeEnc);

	AESWrapper aes(_self.symmetricKey);
	const std::string encrypted = aes.encrypt(file, bytes);
	request.PayloadHeader.contentSize = encrypted.size();

	uint8_t* content = nullptr;
	content = new uint8_t[request.PayloadHeader.contentSize];
	memcpy(content, encrypted.c_str(), request.PayloadHeader.contentSize);
	delete[] file;

	// prepare message to send
	size_t msgSize;
	uint8_t* msgToSend;
	request.header.payloadSize = sizeof(request.PayloadHeader) + request.PayloadHeader.contentSize;
	msgToSend = new uint8_t[sizeof(request) + request.PayloadHeader.contentSize];
	memcpy(msgToSend, &request, sizeof(request));
	memcpy(msgToSend + sizeof(request), content, request.PayloadHeader.contentSize);
	msgSize = sizeof(request) + request.PayloadHeader.contentSize;

	if (!_socketHandler->sendReceive(msgToSend, msgSize, reinterpret_cast<uint8_t* const>(&response), sizeof(response)))
	{
		delete[] content;
		if (msgToSend != reinterpret_cast<uint8_t*>(&request))
			delete[] msgToSend;
		clearLastError();
		_lastError << "Failed communicating with server on " << _socketHandler;
		return false;
	}

	delete[] content;
	delete[] msgToSend;

	// Validate ResponseFileAcception
	if (!validateHeader(response.header, RESPONSE_SUCCESS_FILE_WITH_CRC))
		return false;  // error message updated within.

	sent = true;
	if (fileCRC == response.PayloadHeader.crc)
	{
		informServerCRCValidated(response.PayloadHeader.file.fileName);
	}
	else
	{
		_self.validCRC = false;
		clearLastError();
		_lastError << "CRC validation with server has failed.";
		return false;
	}

	return true;
}
